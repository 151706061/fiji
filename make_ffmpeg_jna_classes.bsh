#!/bin/sh
// 2>/dev/null; exec fiji "$0" "$@" # exec with fiji */

// This script is not meant to be a fully-fledged
// .h -> JNA converter as JNAerator tries to do.
// It is meant to be just good enough for FFMPEG.

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

class LineIterator {
	protected String contents;
	protected int offset, nextOffset;
	protected boolean breakAtSpecials;

	public LineIterator(String contents) {
		this(contents, false);
	}

	public LineIterator(String contents, boolean breakAtSpecials) {
		this.contents = contents;
		this.breakAtSpecials = breakAtSpecials;
		offset = 0;
		nextOffset = -2;
	}

	public boolean next() {
		if (nextOffset == -1 || (nextOffset == contents.length() - 1 && contents.charAt(nextOffset) == '\n'))
			return false;

		offset = nextOffset < 0 ? 0 : nextOffset + (contents.charAt(nextOffset) == '\n' ? 1 : 0);
		nextOffset = contents.indexOf('\n', offset);
		if (breakAtSpecials) {
			for (int off = offset + 1; off < nextOffset; off++) {
				char c = contents.charAt(off);
				if ("{;".indexOf(c) >= 0) {
					nextOffset = off + 1;
					break;
				}
			}
		}
		return true;
	}
	
	public int getOffset() {
		return offset;
	}

	public String getLine() {
		if (nextOffset < 0)
			return contents.substring(offset);
		return contents.substring(offset, nextOffset);
	}
}

String filterOutIf0(String contents) {
	StringBuffer buf = new StringBuffer();
	LineIterator iter = new LineIterator(contents);
	int nest = 0;
	while (iter.next()) {
		String line = iter.getLine();
		if (nest > 0) {
			if (line.trim().startsWith("#if"))
				nest++;
			else if (line.trim().startsWith("#endif"))
				nest--;
		}
		else if (line.trim().startsWith("#if 0"))
			nest++;
		else
			buf.append(line).append('\n');
	}
	return buf.toString();
}

String reduceEmptyLines(String contents) {
	StringBuffer buf = new StringBuffer();
	int offset = 0, length = contents.length();
	while (offset < length && contents.charAt(offset) == '\n')
		offset++;
	for (; offset < length; offset++) {
		char c = contents.charAt(offset);
		if (offset + 1 < length && c == '\n' && contents.charAt(offset + 1) == '\n') {
			offset++;
			while (offset + 1 < length && contents.charAt(offset + 1) == '\n')
				offset++;
			if (offset + 1 < length)
				buf.append(c);
		}
		buf.append(c);
	}
	return buf.toString();
}

String filterOutComments(String contents) {
	StringBuffer buf = new StringBuffer();
	int length = contents.length();
	for (int offset = 0; offset < length; offset++) {
		char c = contents.charAt(offset);
		if (c == '"') {
			buf.append(c);
			while (++offset < length) {
				c = contents.charAt(offset);
				buf.append(c);
				if (c == '\\')
					buf.append(contents.charAt(++offset));
				else if (c == '"')
					break;
			}
			continue;
		}
		if (c == '/' && offset + 1 < length) {
			switch (contents.charAt(offset + 1)) {
				case '/':
					offset++;
					while (++offset < length)
						if (contents.charAt(offset) == '\n')
							break;
					break;
				case '*':
					offset++;
					while (++offset < length)
						if (offset + 2 > length ||
								contents.substring(offset, offset + 2).equals("*/")) {
							offset += 2;
							break;
						}
					break;
				default:
					buf.append(c);
			}
		}
		else
			buf.append(c);
	}
	return reduceEmptyLines(buf.toString().trim());
}

String indent(String contents, int level) {
	if (level < 1)
		return contents;
	String tabs = "\t";
	while (level-- > 1)
		tabs += "\t";
	LineIterator iter = new LineIterator(contents);
	StringBuffer buf = new StringBuffer();
	while (iter.next()) {
		String line = iter.getLine();
		if (!line.equals(""))
			buf.append(tabs);
		buf.append(line).append("\n");
	}
	return buf.toString();
}

Pattern compile(String regex) {
	return Pattern.compile(regex
		.replace("TYPE", "(?:unsigned |const )*(?:unsigned|void|char|short|int|long|float|double|u?int(?:8|16|32|64)_t|enum IDENT|struct\\s+IDENT|AV[A-Za-z_0-9]+)\\**\\s*?\\**")
		.replace("IDENT", "[A-Za-z_][A-Za-z_0-9]*")
		.replace(" *", "\\s*")
		.replace(" ", "\\s+")
		.replace("SPACE", " "), Pattern.DOTALL);
}

Pattern guardPattern =
	compile("^#ifndef (IDENT)[^\n]*\n"
	+ " *#define (IDENT)[^\n]*\n"
	+ "(.*\n|)"
	+ " *#endif[^\n]*\n?$");
Pattern definePattern =
	compile("^# *define (IDENT) *(.*?) *$");
Pattern externVariablePattern =
	compile("^extern (TYPE) *(IDENT); *$");
Pattern staticVariablePattern =
	compile("^static (TYPE) *(IDENT)( *\\[[^\\]]*\\])*( *=.*)?; *$");
Pattern functionPattern =
	compile("^(?:extern )?(TYPE) *(IDENT)\\((void|((TYPE *IDENT, *)*TYPE *IDENT)?)\\) *(?:av_const *)?;$");
Pattern parameterPattern =
	compile("^(TYPE) *(IDENT)");
Pattern enumPattern =
	compile("^enum (IDENT)? *\\{ *((IDENT( *= *-?\\d+)?,? *)*) *\\};$");
Pattern skipDefine =
	compile("^AV_(?:STRINGIFY|TOSTRING|GLUE|JOIN|PRAGMA|VERSION_INT|VERSION_DOT|VERSION)");
Pattern structPattern =
	compile("^(?:typedef )?struct (IDENT)? *\\{$");
Pattern structMemberPattern =
	compile("^(TYPE) *(IDENT)(\\[([^\\]]+)\\])?; *$");
Pattern structEndPattern =
	compile("^\\} *(IDENT)? *;$");

String filterOutGuard(String contents) {
	Matcher matcher = guardPattern.matcher(contents);
	if (matcher.matches() && matcher.group(1).trim().equals(matcher.group(2).trim()))
		return matcher.group(3);
	return contents;
}

Matcher match(Pattern pattern, String line) {
	Matcher matcher = pattern.matcher(line);
	return matcher.matches() ? matcher : null;
}

String capitalize(String name) {
	if (name.length() == 0)
		return name;
	return name.substring(0, 1).toUpperCase() + name.substring(1);
}

String stripPrefix(String string, String prefix) {
	return string.startsWith(prefix) ? string.substring(prefix.length()) : string;
}

import java.util.TreeMap;

String currentLib;
TreeMap name2lib = new TreeMap();

String addLibPrefix(String name) {
	String lib = name2lib.get(name);
	if (lib == null || lib.equals(currentLib))
		return name;
	return lib + "." + name;
}

String plusStars(String string, int stars) {
	if (stars == 0)
		return string;
	String suffix = " ";
	while (--stars >= 0)
		suffix += "*";
	return string + suffix;
}

String translateType(String type, boolean inStruct) {
	if (type.equals("const char *"))
		return "String";
	int stars = 0;
	for (;;) {
		if (type.endsWith("*"))
			stars++;
		else if (!type.endsWith(" "))
			break;
		type = type.substring(0, type.length() - 1);
	}
	if (type.startsWith("const "))
		type = type.substring(6);
	if (type.startsWith("struct ") || Character.isUpperCase(type.charAt(0))) {
		type = stripPrefix(type, "struct ");
		if (inStruct) {
			if (stars == 0)
				return type;
			return "PointerByReference /* " + plusStars(type, stars) + " */";
		}
		if (stars == 0)
			return type + ".ByValue";
		if (stars == 1)
			return type;
		return "PointerByReference /* " + plusStars(type, stars) + " */";
	}
	if (type.equals("unsigned"))
		type = "int";
	else if (type.startsWith("unsigned "))
		type = type.substring(9);
	if (type.equals("uint8_t") || type.equals("int8_t") || type.equals("char"))
		type = "byte";
	else if (type.equals("long"))
		type = "NativeLong";
	else if (type.equals("uint64_t") || type.equals("int64_t"))
		type = "long";
	else if (type.equals("uint32_t") || type.equals("int32_t"))
		type = "int";
	else if (type.startsWith("enum "))
		type = "int /* " + type + " */";
	if (stars == 0)
		return type;
	if (stars == 1)
		if (type.equals("byte"))
			return "byte[]"; // assume that it's a buffer
		else
			return capitalize(type) + "ByReference";
	return "PointerByReference /* " + plusStars(type, stars) + " */";
}

String handleStruct(String line, int level, LineIterator iter) {
	Matcher matcher = match(structPattern, line);
	if (matcher == null)
		return null;
	name = matcher.group(1);
	StringBuffer buf = new StringBuffer();
	while (iter.next()) {
		line = iter.getLine().trim();
		if ((matcher = match(structEndPattern, line)) != null) {
			if (matcher.group(1) != null)
				name = matcher.group(1);
			break;
		}
		String inner = handleStruct(line, level + 1, iter);
		if (inner != null) {
			buf.append(inner);
			continue;
		}
		if ((matcher = match(structMemberPattern, line)) == null) {
			if (!line.equals(""))
				buf.append("UNHANDLED: ").append(line).append("\n");
			continue;
		}
		String type = translateType(matcher.group(1), true);
		buf.append(type);
		if (matcher.group(3) != null)
			buf.append("[]");
		buf.append(" ").append(matcher.group(2));
		if (matcher.group(3) != null) {
			buf.append(" = new ").append(type).append(matcher.group(3));
		}
		buf.append(";\n");
	}
	if (level == 0)
{ if (name == null) throw new Exception("last line: " + line + ", so far:\n" + buf.toString());
		name2lib.put(name, currentLib);
}
	return indent("public static class " + name + " extends Structure {\n"
			+ "\tpublic static class ByValue extends " + name + " implements Structure.ByValue {}\n", level)
		+ indent(buf.toString(), level + 1)
		+ indent("}\n", level);
}

String toJNA(String contents) {
	Matcher matcher;
	StringBuffer buf = new StringBuffer();
	LineIterator iter = new LineIterator(contents, true);
	while (iter.next()) {
		String line = iter.getLine().trim();
		// Handle backslashes at the end of the line
		while (line.endsWith("\\") && iter.next())
			line = line.substring(0, line.length() - 1) + iter.getLine();

		if (line.equals("")) {
			buf.append("\n");
			continue;
		}

		if (line.charAt(0) == '#') {
			if ((matcher = match(definePattern, line)) != null &&
					!skipDefine.matcher(matcher.group(1)).matches()) {
				String value = matcher.group(2);
				String type = "int";
				if (value.startsWith("\"") || value.startsWith("AV_VERSION("))
					type = "String";
				else if (value.endsWith("l"))
					type = "long";
				else if (value.startsWith("INT64_t(")) {
					type = "long";
					value = value.substring(8, value.length() - 1);
				}
				else if (value.indexOf('<') > 0 || value.indexOf('>') > 0 || value.indexOf("==") > 0)
					type = "boolean";
				buf.append("public static final ").append(type).append(" ")
					.append(matcher.group(1)).append(" = ").append(value).append(";\n");
			}
			continue;
		}

		// Handle structs
		String struct = handleStruct(line, 0, iter);
		if (struct != null) {
			buf.append(struct);
			continue;
		}

		// Read until end of statement
		while (!line.endsWith(";") && iter.next())
			line += "\n" + iter.getLine();

		// Handle extern variables
		if ((matcher = match(externVariablePattern, line)) != null)
			continue; // TODO: handle via library.getFunction(name).getInt(0)

		// Handle local variables
		if ((matcher = match(staticVariablePattern, line)) != null)
			continue;

		// Handle function
		if ((matcher = match(functionPattern, line)) != null) {
			buf.append(translateType(matcher.group(1), false)).append(" ").append(matcher.group(2)).append("(");
			boolean first = true;
			for (String parameter : matcher.group(3).split("\\s*,\\s*")) {
				if (first)
					first = false;
				else
					buf.append(", ");
				if (parameter.equals("void"))
					continue;
				if ((matcher = match(parameterPattern, parameter)) != null)
					buf.append(translateType(matcher.group(1), false)).append(" ").append(matcher.group(2));
				else
					buf.append("UNHANDLED parameter ").append(parameter);
			}
			buf.append(");\n");
			continue;
		}

		// Handle enums
		if ((matcher = match(enumPattern, line)) != null) {
			buf.append("// enum ");
			if (matcher.group(1) != null)
				buf.append(matcher.group(1));
			buf.append("\n");
			int number = 0;
			for (String item : matcher.group(2).split("\\s*,\\s*")) {
				int equals = item.indexOf('=');
				if (equals > 0) {
					number = Integer.parseInt(item.substring(equals + 1).trim());
					item = item.substring(0, equals);
				}
				item = item.trim();
				buf.append("public static final int ").append(item).append(" = " + number++).append(";\n");
			}
			continue;
		}

		// Handle struct
		if (line.startsWith("struct ") && line.indexOf('{') < 0)
			continue; // TODO: remember undefined ones and define them as extending Pointer
		buf.append("UNHANDLED: ").append(line).append("\n");
	}
	return buf.toString();
}

String readFile(File path) {
	FileReader reader = new FileReader(path);
	StringBuffer buf = new StringBuffer();
	char[] cBuf = new char[65536];
	for (;;) {
		int count = reader.read(cBuf);
		if (count < 0)
			break;
		buf.append(cBuf, 0, count);
	}
	reader.close();
	return buf.toString();
}

String defaultMacros = "public static final int AV_VERSION_INT(int a, int b, int c) {\n"
	+ "\treturn (a << 16) | (b << 8) | c;\n"
	+ "}\n"
	+ "\n"
	+ "public static final String AV_VERSION(int a, int b, int c) {\n"
	+ "\treturn \"\" + a + \".\" + b + \".\" + c;\n"
	+ "}\n";

void handleHeaders(String pathToHeaders, String libName, String packageName, String outDir) {
	File outFile = new File(outDir, packageName.replace('.', '/') + "/" + libName + ".java");
	outFile.getParentFile().mkdirs();
	FileWriter out = new FileWriter(outFile);

	out.write("package " + packageName + ";\n\n");
	out.write("public interface " + libName + " extends Library {\n");
	out.write(indent(defaultMacros, 1));

	print("Generating " + libName);
print(pathToHeaders);
	File path = new File(pathToHeaders);
	for (String file : path.list()) {
		if (!file.endsWith(".h"))
			continue;
		print("Translating " + file);
		out.write("\n\t// Header: " + file + "\n");
		String contents = readFile(new File(path, file));
		contents = toJNA(filterOutGuard(filterOutComments(filterOutIf0(contents))).trim());
		out.write(indent(contents, 1));
	}

	out.write("}\n");
	out.close();
}

String ffmpegDir = "/home/gene099/fiji/work/fantana/ffmpeg/ffmpeg/";
String outDir = "/home/gene099/fiji/work/fantana/ffmpeg/classes/";

/*
contents = readFile(new File(ffmpegDir, "libavcodec/dcadata.h"));
//contents = "static const uint8_t dca_default_coeffs[16][5][2] = {\n1\n};";
print(toJNA(filterOutGuard(filterOutComments(filterOutIf0(contents))).trim()));
return;
*/

//for (String lib : new String[] { "avutil", "avcore", "avdevice", "swscale", "avfilter", "avcodec", "avformat" }) {
for (String lib : new String[] { "avcodec", "avformat" }) {
	if (!ffmpegDir.endsWith("/"))
		ffmpegDir += "/";

	currentLib = lib.toUpperCase();
	handleHeaders(ffmpegDir + "lib" + lib, currentLib, "fiji.ffmpeg", outDir);
}